# Configuration Parameters

Below is a list of all the configurable parameters within the SPARK MAX. Parameters can be set through the CAN or USB interfaces. The parameters are saved in a different region of memory from the device firmware and persist through a firmware update.&#x20;

<table data-header-hidden><thead><tr><th width="150">Name</th><th width="150" align="center">ID</th><th width="150" align="center">Type</th><th width="150" align="center">Default</th><th width="300">Description</th></tr></thead><tbody><tr><td>Name</td><td align="center">ID</td><td align="center">Type</td><td align="center">Default</td><td>Description</td></tr><tr><td>kCanID</td><td align="center">0</td><td align="center">uint</td><td align="center">0</td><td>CAN ID<br><br>This parameter persists through a normal firmware update.</td></tr><tr><td>kInputMode</td><td align="center">1</td><td align="center">Input Mode</td><td align="center">0</td><td>Input mode, this parameter is read only and the input mode is detected by the firmware automatically.<br>0 - PWM<br>1 - CAN<br>2 - USB</td></tr><tr><td>kMotorType</td><td align="center">2</td><td align="center">Motor Type</td><td align="center">BRUSHLESS</td><td>Motor type:<br><br>0 - Brushed<br>1 - Brushless<br><br>This parameter persists through a normal firmware update.</td></tr><tr><td>Reserved</td><td align="center">3</td><td align="center">-</td><td align="center"></td><td>Reserved</td></tr><tr><td>kSensorType</td><td align="center">4</td><td align="center">Sensor Type</td><td align="center">HALL_EFFECT</td><td>Sensor type:<br>0 - No Sensor<br>1 - Hall Sensor<br>2 - Encoder<br>This parameter persists through a normal firmware update.</td></tr><tr><td>kCtrlType</td><td align="center">5</td><td align="center">Ctrl Type</td><td align="center">CTRL_DUTY_CYCLE</td><td>Control Type, this is a read only parameter of the currently active control type. The control type is changed by calling the correct API.<br>0 - Duty Cycle<br>1 - Velocity<br>2 - Voltage<br>3 - Position</td></tr><tr><td>kIdleMode</td><td align="center">6</td><td align="center">Idle Mode</td><td align="center">IDLE_COAST</td><td>State of the half bridge when the motor controller commands zero output or is disabled.<br>0 - Coast<br>1 - Brake<br>This parameter persists through a normal firmware update.</td></tr><tr><td>kInputDeadband</td><td align="center">7</td><td align="center">float32</td><td align="center">%0.05</td><td>Percent of the input which results in zero output for PWM mode.<br>This parameter persists through a normal firmware update.</td></tr><tr><td>Reserved</td><td align="center">8</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">9</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>kPolePairs</td><td align="center">10</td><td align="center">uint</td><td align="center">7</td><td>Number of pole pairs for the brushless motor. This is the number of poles/2 and can be determined by either counting the number of magnets or counting the number of windings and dividing by 3. This is an important term for speed regulation to properly calculate the speed.</td></tr><tr><td>kCurrentChop</td><td align="center">11</td><td align="center">float32</td><td align="center">115/Amps</td><td>If the half bridge detects this current limit, it will disable the motor driver for a fixed amount of time set by kCurrentChopCycles. This is a low sophistication 'current control'. Set to 0 to disable. The max value is 125.</td></tr><tr><td>kCurrentChopCycles</td><td align="center">12</td><td align="center">uint</td><td align="center">0</td><td>Number of PWM Cycles for the h-bridge to be off in the case that the current limit is set. Min = 1, multiples of PWM period (50μs). During this time the current will be recirculating through the low side MOSFETs, so instead of 'freewheeling' the diodes, the bridge will be in brake mode during this time.</td></tr><tr><td>kP_0</td><td align="center">13</td><td align="center">float32</td><td align="center">0</td><td>Proportional gain constant for gain slot 0.</td></tr><tr><td>kI_0</td><td align="center">14</td><td align="center">float32</td><td align="center">0</td><td>Integral gain constant for gain slot 0.</td></tr><tr><td>kD_0</td><td align="center">15</td><td align="center">float32</td><td align="center">0</td><td>Derivative gain constant for gain slot 0.</td></tr><tr><td>kF_0</td><td align="center">16</td><td align="center">float32</td><td align="center">0</td><td>Feed Forward gain constant for gain slot 0.</td></tr><tr><td>kIZone_0</td><td align="center">17</td><td align="center">float32</td><td align="center">0</td><td>Integrator zone constant for gain slot 0. The PIDF loop integrator will only accumulate while the setpoint is within IZone of the target.</td></tr><tr><td>kDFilter_0</td><td align="center">18</td><td align="center">float32</td><td align="center">0</td><td>PIDF derivative filter constant for gain slot 0.</td></tr><tr><td>kOutputMin_0</td><td align="center">19</td><td align="center">float32</td><td align="center">-1</td><td>Max output constant for gain slot 0. This is the max output of the controller.</td></tr><tr><td>kOutputMax_0</td><td align="center">20</td><td align="center">float32</td><td align="center">1</td><td>Min output constant for gain slot 0. This is the min output of the controller.</td></tr><tr><td>kP_1</td><td align="center">21</td><td align="center">float32</td><td align="center">0</td><td>Proportional gain constant for gain slot 1.</td></tr><tr><td>kI_1</td><td align="center">22</td><td align="center">float32</td><td align="center">0</td><td>Integral gain constant for gain slot 1.</td></tr><tr><td>kD_1</td><td align="center">23</td><td align="center">float32</td><td align="center">0</td><td>Derivative gain constant for gain slot 1.</td></tr><tr><td>kF_1</td><td align="center">24</td><td align="center">float32</td><td align="center">0</td><td>Feed Forward gain constant for gain slot 1.</td></tr><tr><td>kIZone_1</td><td align="center">25</td><td align="center">float32</td><td align="center">0</td><td>Integrator zone constant for gain slot 1. The PIDF loop integrator will only accumulate while the setpoint is within IZone of the target.</td></tr><tr><td>kDFilter_1</td><td align="center">26</td><td align="center">float32</td><td align="center">0</td><td>PIDF derivative filter constant for gain slot 1.</td></tr><tr><td>kOutputMin_1</td><td align="center">27</td><td align="center">float32</td><td align="center">-1</td><td>Max output constant for gain slot 1. This is the max output of the controller.</td></tr><tr><td>kOutputMax_1</td><td align="center">28</td><td align="center">float32</td><td align="center">1</td><td>Min output constant for gain slot 1. This is the min output of the controller.</td></tr><tr><td>kP_2</td><td align="center">29</td><td align="center">float32</td><td align="center">0</td><td>Proportional gain constant for gain slot 2.</td></tr><tr><td>kI_2</td><td align="center">30</td><td align="center">float32</td><td align="center">0</td><td>Integral gain constant for gain slot 2.</td></tr><tr><td>kD_2</td><td align="center">31</td><td align="center">float32</td><td align="center">0</td><td>Derivative gain constant for gain slot 2.</td></tr><tr><td>kF_2</td><td align="center">32</td><td align="center">float32</td><td align="center">0</td><td>Feed Forward gain constant for gain slot 2.</td></tr><tr><td>kIZone_2</td><td align="center">33</td><td align="center">float32</td><td align="center">0</td><td>Integrator zone constant for gain slot 2. The PIDF loop integrator will only accumulate while the setpoint is within IZone of the target.</td></tr><tr><td>kDFilter_2</td><td align="center">34</td><td align="center">float32</td><td align="center">0</td><td>PIDF derivative filter constant for gain slot 2.</td></tr><tr><td>kOutputMin_2</td><td align="center">35</td><td align="center">float32</td><td align="center">-1</td><td>Max output constant for gain slot 2. This is the max output of the controller.</td></tr><tr><td>kOutputMax_2</td><td align="center">36</td><td align="center">float32</td><td align="center">1</td><td>Min output constant for gain slot 2. This is the min output of the controller.</td></tr><tr><td>kP_3</td><td align="center">37</td><td align="center">float32</td><td align="center">0</td><td>Proportional gain constant for gain slot 3.</td></tr><tr><td>kI_3</td><td align="center">38</td><td align="center">float32</td><td align="center">0</td><td>Integral gain constant for gain slot 3.</td></tr><tr><td>kD_3</td><td align="center">39</td><td align="center">float32</td><td align="center">0</td><td>Derivative gain constant for gain slot 3.</td></tr><tr><td>kF_3</td><td align="center">40</td><td align="center">float32</td><td align="center">0</td><td>Feed Forward gain constant for gain slot 3.</td></tr><tr><td>kIZone_3</td><td align="center">41</td><td align="center">float32</td><td align="center">0</td><td>Integrator zone constant for gain slot 3. The PIDF loop integrator will only accumulate while the setpoint is within IZone of the target.</td></tr><tr><td>kDFilter_3</td><td align="center">42</td><td align="center">float32</td><td align="center">0</td><td>PIDF derivative filter constant for gain slot 3.</td></tr><tr><td>kOutputMin_3</td><td align="center">43</td><td align="center">float32</td><td align="center">-1</td><td>Max output constant for gain slot 3. This is the max output of the controller.</td></tr><tr><td>kOutputMax_3</td><td align="center">44</td><td align="center">float32</td><td align="center">1</td><td>Min output constant for gain slot 3. This is the min output of the controller.</td></tr><tr><td>Reserved</td><td align="center">45</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">46</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">47</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">48</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">49</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>kLimitSwitchFwdPolarity</td><td align="center">50</td><td align="center">bool</td><td align="center">0</td><td>Forward Limit Switch polarity.<br>0 - Normally Open<br>1 - Normally Closed</td></tr><tr><td>kLimitSwitchRevPolarity</td><td align="center">51</td><td align="center">bool</td><td align="center">0</td><td>Reverse Limit Switch polarity.<br>0 - Normally Open<br>1 - Normally Closed</td></tr><tr><td>kHardLimitFwdEn</td><td align="center">52</td><td align="center">bool</td><td align="center">1</td><td>Limit switch enable, enabled by default</td></tr><tr><td>kHardLimitRevEn</td><td align="center">53</td><td align="center">bool</td><td align="center">1</td><td>Limit switch enable, enabled by default</td></tr><tr><td>Reserved</td><td align="center">54</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">55</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>kRampRate</td><td align="center">56</td><td align="center">float32</td><td align="center">V/s 0</td><td>Voltage ramp rate active for all control modes in % output per second, a value of 0 disables this feature. All APIs take the reciprocal to make the unit 'time from 0 to full'.</td></tr><tr><td>kFollowerID</td><td align="center">57</td><td align="center">uint</td><td align="center">0</td><td>CAN EXTID of the message with data to follow</td></tr><tr><td>kFollowerConfig</td><td align="center">58</td><td align="center">uint</td><td align="center">0</td><td>Special configuration register for setting up to follow on a repeating message (follower mode). CFG[0] to CFG[3] where CFG[0] is the motor output start bit (LSB), CFG[1] is the motor output stop bit (MSB). CFG[0] - CFG[1] determines endianness. CFG[2] bits determine sign mode and inverted, CFG[3] sets a preconfigured controller (0x1A = REV, 0x1B = Talon/Victor style as of 2018 season)</td></tr><tr><td>kSmartCurrentStallLimit</td><td align="center">59</td><td align="center">uint</td><td align="center">80A</td><td>Smart Current Limit at stall, or any RPM less than kSmartCurrentConfig RPM.</td></tr><tr><td>kSmartCurrentFreeLimit</td><td align="center">60</td><td align="center">uint</td><td align="center">20A</td><td>Smart current limit at free speed</td></tr><tr><td>kSmartCurrentConfig</td><td align="center">61</td><td align="center">uint</td><td align="center">10000</td><td>Smart current limit RPM value to start linear reduction of current limit. Set this > free speed to disable.</td></tr><tr><td>Reserved</td><td align="center">62</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">63</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">64</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">65</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">66</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">67</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">68</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>kEncoderCountsPerRev</td><td align="center">69</td><td align="center">uint</td><td align="center">4096</td><td>Number of encoder counts in a single revolution, counting every edge on the A and B lines of a quadrature encoder. (Note: This is different than the CPR spec of the encoder which is 'Cycles per revolution'. This value is 4 * CPR.</td></tr><tr><td>kEncoderAverageDepth</td><td align="center">70</td><td align="center">uint</td><td align="center">64</td><td>Number of samples to average for velocity data based on quadrature encoder input. This value can be between 1 and 64.</td></tr><tr><td>kEncoderSampleDelta</td><td align="center">71</td><td align="center">uint</td><td align="center">200 per 500us</td><td>Delta time value for encoder velocity measurement in 500μs increments. The velocity calculation will take delta the current sample, and the sample x * 500μs behind, and divide by this the sample delta time. Can be any number between 1 and 255</td></tr><tr><td>Reserved</td><td align="center">72</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">73</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">74</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>kCompensatedNominalVoltage</td><td align="center">75</td><td align="center">float32</td><td align="center">0 V</td><td>In voltage compensation mode mode, this is the max scaled voltage.</td></tr><tr><td>kSmartMotionMaxVelocity_0</td><td align="center">76</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMaxAccel_0</td><td align="center">77</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMinVelOutput_0</td><td align="center">78</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionAllowedClosedLoopError_0</td><td align="center">79</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionAccelStrategy_0</td><td align="center">80</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMaxVelocity_1</td><td align="center">81</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMaxAccel_1</td><td align="center">82</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMinVelOutput_1</td><td align="center">83</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionAllowedClosedLoopError_1</td><td align="center">84</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionAccelStrategy_1</td><td align="center">85</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMaxVelocity_2</td><td align="center">86</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMaxAccel_2</td><td align="center">87</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMinVelOutput_2</td><td align="center">88</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionAllowedClosedLoopError_2</td><td align="center">89</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionAccelStrategy_2</td><td align="center">90</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMaxVelocity_3</td><td align="center">91</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMaxAccel_3</td><td align="center">92</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionMinVelOutput_3</td><td align="center">93</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionAllowedClosedLoopError_3</td><td align="center">94</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSmartMotionAccelStrategy_3</td><td align="center">95</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kIMaxAccum_0</td><td align="center">96</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder1_0</td><td align="center">97</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder2_0</td><td align="center">98</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder3_0</td><td align="center">99</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kIMaxAccum_1</td><td align="center">100</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder1_1</td><td align="center">101</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder2_1</td><td align="center">102</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder3_1</td><td align="center">103</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kIMaxAccum_2</td><td align="center">104</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder1_2</td><td align="center">105</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder2_2</td><td align="center">106</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder3_2</td><td align="center">107</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kIMaxAccum_3</td><td align="center">108</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder1_3</td><td align="center">109</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder2_3</td><td align="center">110</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kSlot3Placeholder3_3</td><td align="center">111</td><td align="center">float32</td><td align="center">0</td><td></td></tr><tr><td>kPositionConversionFactor</td><td align="center">112</td><td align="center">float32</td><td align="center">1</td><td></td></tr><tr><td>kVelocityConversionFactor</td><td align="center">113</td><td align="center">float32</td><td align="center">1</td><td></td></tr><tr><td>kClosedLoopRampRate</td><td align="center">114</td><td align="center">float32</td><td align="center">0 DC/sec</td><td></td></tr><tr><td>kSoftLimitFwd</td><td align="center">115</td><td align="center">float32</td><td align="center">0</td><td>Soft limit forward value</td></tr><tr><td>kSoftLimitRev</td><td align="center">116</td><td align="center">float32</td><td align="center">0</td><td>Soft limit reverse value</td></tr><tr><td>Reserved</td><td align="center">117</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">118</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>kAnalogPositionConversion</td><td align="center">119</td><td align="center">float32</td><td align="center">1 rev/volt</td><td>Conversion factor for position from analog sensor. This value is multiplied by the voltage to give an output value.</td></tr><tr><td>kAnalogVelocityConversion</td><td align="center">120</td><td align="center">float32</td><td align="center">1 vel/v/s</td><td>Conversion factor for velocity from analog sensor. This value is multiplied by the voltage to give an output value.</td></tr><tr><td>kAnalogAverageDepth</td><td align="center">121</td><td align="center">uint</td><td align="center">0</td><td>Number of samples in moving average of velocity.</td></tr><tr><td>kAnalogSensorMode</td><td align="center">122</td><td align="center">uint</td><td align="center">0</td><td>0 Absolute: In this mode the sensor position is always read as voltage * conversion factor and reads the absolute position of the sensor. In this mode setPosition() does not have an effect.<br><br>1 Relative: In this mode the voltage difference is summed to calculate a relative position.</td></tr><tr><td>kAnalogInverted</td><td align="center">123</td><td align="center">bool</td><td align="center">0</td><td>When inverted, the voltage is calculated as (ADC Full Scale - ADC Reading). This means that for absolute mode, the sensor value is 3.3V - voltage. In relative mode the direction is reversed.</td></tr><tr><td>kAnalogSampleDelta</td><td align="center">124</td><td align="center">uint</td><td align="center">0</td><td>Delta time between samples for velocity measurement</td></tr><tr><td>Reserved</td><td align="center">125</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>Reserved</td><td align="center">126</td><td align="center">-</td><td align="center">-</td><td>Reserved</td></tr><tr><td>kDataPortConfig</td><td align="center">127</td><td align="center">uint</td><td align="center">0</td><td>0: Default configuration using limit switches<br><br>1: Alternate Encoder Mode - limit switches are disabled and alternate encoder is enabled.<br>This parameter persists through a normal firmware update.</td></tr><tr><td>kAltEncoderCountsPerRev</td><td align="center">128</td><td align="center">uint</td><td align="center">4096</td><td>Number of encoder counts in a single revolution, counting every edge on the A and B lines of a quadrature encoder. (Note: This is different than the CPR spec of the encoder which is 'Cycles per revolution'. This value is 4 * CPR.</td></tr><tr><td>kAltEncoderAverageDepth</td><td align="center">129</td><td align="center">uint</td><td align="center">64</td><td>Number of samples to average for velocity data based on quadrature encoder input. This value can be between 1 and 64.</td></tr><tr><td>kAltEncoderSampleDelta</td><td align="center">130</td><td align="center">uint</td><td align="center">200</td><td>Delta time value for encoder velocity measurement in 500μs increments. The velocity calculation will take delta the current sample, and the sample x * 500μs behind, and divide by this the sample delta time. Can be any number between 1 and 255.</td></tr><tr><td>kAltEncoderInverted</td><td align="center">131</td><td align="center">bool</td><td align="center">0</td><td>Invert the phase of the encoder sensor. This is useful when the motor direction is opposite of the motor direction.</td></tr><tr><td>kAltEncoderPositionFactor</td><td align="center">132</td><td align="center">float32</td><td align="center">1</td><td>Value multiplied by the native units (rotations) of the encoder for position.</td></tr><tr><td>kAltEncoderVelocityFactor</td><td align="center">133</td><td align="center">float32</td><td align="center">1</td><td>Value multiplied by the native units (rotations) of the encoder for velocity.</td></tr></tbody></table>
